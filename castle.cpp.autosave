#include "castle.h"
#include<QPixmap>
#include<QVector>
#include<QPointF>
#include<QPolygonF>
#include"arrow.h"
#include<QLineF>
#include"scene.h"
#include<QGraphicsScene>
#include<QTimer>
#include"arrow.h"
#include"scene.h"
#include"luffy.h"
#include"zoro1.h"
#include"zoro2.h"
#include"bread1.h"
#include"bread2.h"
#include"curry1.h"
#include"curry2.h"
#include"din1.h"
#include"din2.h"
#include"bo1.h"
#include"bo2.h"
#include"totoro.h"
#include"lulumi1.h"
#include"lulumi2.h"
#include"dialog.h"

Castle::Castle(QGraphicsItem *parent) : QObject(), QGraphicsPixmapItem(parent)
{
    hp = 30;
    // Create points vector
    QVector<QPointF> points;
    points << QPoint(1,0) << QPoint(2,0) << QPoint(3,1) << QPoint(3,2) << QPoint(2,3) << QPoint(1,3) << QPoint(0,2) << QPoint(0,1);

    // Scale points
    int SCALE_FACTOR = 100;
    for(size_t i=0,n=points.size();i<n;++i )
        points[i] *= SCALE_FACTOR;

    // Create the QGraphicsPolygonItem
    attack_area = new QGraphicsPolygonItem(QPolygonF(points),this);
    attack_area->QAbstractGraphicsShapeItem::setPen(QPen(Qt::red));

    //Move the polygon
    QPointF poly_center(1.5,1.5);
    poly_center *= SCALE_FACTOR;
    poly_center = mapToScene(poly_center);
    QPointF tower_center(x()+400,y()+175);
    QLineF ln(poly_center,tower_center);
    attack_area->setPos(x()+ln.dx(),y()+ln.dy());

    QTimer * timer = new QTimer();
    connect(timer,SIGNAL(timeout()),this,SLOT(acquire_target()));
    connect(timer,SIGNAL(timeout()),this,SLOT(blood()));
    timer->start(1000);

}

double Castle::distanceTo(QGraphicsItem *item)
{
    QLineF ln(pos(),item->pos());
    return ln.length();
}

void Castle::attack()
{
    Arrow * arrow = new Arrow();
    arrow->setPos(x()+400,y()+175);

    QLineF ln(QPointF(x()+400,y()+175),QPointF(attack_destn.x()+50,attack_destn.y()+50));
    int angle = ln.angle();

    arrow->setRotation(-angle);
    this->scene()->addItem(arrow);
 }

void Castle::acquire_target()
{
    QList<QGraphicsItem *> colliding_items = attack_area->collidingItems();
    if(colliding_items.size()<=4)
    {
        has_target = false;
        return;
    }

    double closest_dist =500;
    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Luffy * luffy = dynamic_cast<Luffy *>(colliding_items[i]);
        if(luffy)
        {
            double this_dist = distanceTo(luffy);
            if(this_dist<closest_dist)
            {
                closest_dist = this_dist;
                closest_pos = colliding_items[i]->pos();
                has_target = true;
            }
        }
    }
    attack_destn = closest_pos;
    attack();


    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Zoro1 * zoro1 = dynamic_cast<Zoro1 *>(colliding_items[i]);
        {
            if(zoro1)
            {
                double this_dist = distanceTo(zoro1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Bread1 * bread1 = dynamic_cast<Bread1 *>(colliding_items[i]);
        {
            if(bread1)
            {
                double this_dist = distanceTo(bread1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Curry1 * curry1 = dynamic_cast<Curry1 *>(colliding_items[i]);
        {
            if(curry1)
            {
                double this_dist = distanceTo(curry1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Din1 * din1 = dynamic_cast<Din1 *>(colliding_items[i]);
        {
            if(din1)
            {
                double this_dist = distanceTo(din1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Bo1 * bo1 = dynamic_cast<Bo1 *>(colliding_items[i]);
        {
            if(bo1)
            {
                double this_dist = distanceTo(bo1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Totoro * totoro1 = dynamic_cast<Totoro *>(colliding_items[i]);
        {
            if(totoro1)
            {
                double this_dist = distanceTo(totoro1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Lulumi1 * lulumi1 = dynamic_cast<Lulumi1 *>(colliding_items[i]);
        {
            if(lulumi1)
            {
                double this_dist = distanceTo(lulumi1);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Zoro2 * zoro2 = dynamic_cast<Zoro2 *>(colliding_items[i]);
        {
            if(zoro2)
            {
                double this_dist = distanceTo(zoro2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Bread2 * bread2 = dynamic_cast<Bread2 *>(colliding_items[i]);
        {
            if(bread2)
            {
                double this_dist = distanceTo(bread2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Curry2 * curry2 = dynamic_cast<Curry2 *>(colliding_items[i]);
        {
            if(curry2)
            {
                double this_dist = distanceTo(curry2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Din2 * din2 = dynamic_cast<Din2 *>(colliding_items[i]);
        {
            if(din2)
            {
                double this_dist = distanceTo(din2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Bo2 * bo2 = dynamic_cast<Bo2 *>(colliding_items[i]);
        {
            if(bo2)
            {
                double this_dist = distanceTo(bo2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();

    for(size_t i =0, n = colliding_items.size(); i<n ; ++i)
    {
        Lulumi2 * lulumi2 = dynamic_cast<Lulumi2 *>(colliding_items[i]);
        {
            if(lulumi2)
            {
                double this_dist = distanceTo(lulumi2);
                if(this_dist<closest_dist)
                {
                    closest_dist = this_dist;
                    closest_pos = colliding_items[i]->pos();
                    has_target = true;
                }
            }
        }
    }
    attack_destn = closest_pos;
    attack();
}

void Castle::blood()
{
    QList<QGraphicsItem *> reaching_items = this->collidingItems();
    if(reaching_items.size()<=1)
    {
        damaged = false;
        return;
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Luffy * luffy = dynamic_cast<Luffy *>(reaching_items[i]);
        if(luffy)
        {
            hp -= 3;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Zoro1 * zoro1 = dynamic_cast<Zoro1 *>(reaching_items[i]);
        if(zoro1)
        {
           hp -= 3;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Zoro2 * zoro2 = dynamic_cast<Zoro2 *>(reaching_items[i]);
        if(zoro2)
        {
            hp -= 3;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Bread1 * bread1 = dynamic_cast<Bread1 *>(reaching_items[i]);
        if(bread1)
        {
           hp -= 4;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Bread2 * bread2 = dynamic_cast<Bread2 *>(reaching_items[i]);
        if(bread2)
        {
            hp -= 4;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Curry1 * curry1 = dynamic_cast<Curry1 *>(reaching_items[i]);
        if(curry1)
        {
            hp -= 4;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Curry2 * curry2 = dynamic_cast<Curry2 *>(reaching_items[i]);
        if(curry2)
        {
            hp -= 4;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Din1 * din1 = dynamic_cast<Din1 *>(reaching_items[i]);
        if(din1)
        {
            hp -= 2;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Din2 * din2 = dynamic_cast<Din2 *>(reaching_items[i]);
        if(din2)
        {
            hp -= 2;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Bo1 * bo1 = dynamic_cast<Bo1 *>(reaching_items[i]);
        if(bo1)
        {
            hp -= 0;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Bo2 * bo2 = dynamic_cast<Bo2 *>(reaching_items[i]);
        if(bo2)
        {
            hp -= 0;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Totoro * totoro = dynamic_cast<Totoro *>(reaching_items[i]);
        if(totoro)
        {
            hp -= 5;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Lulumi1 * lulumi1 = dynamic_cast<Lulumi1 *>(reaching_items[i]);
        if(lulumi1)
        {
            hp -= 4;
        }
    }
    for(size_t i = 0, n = reaching_items.size(); i<n; ++i)
    {
        Lulumi2 * lulumi2 = dynamic_cast<Lulumi2 *>(reaching_items[i]);
        if(lulumi2)
        {
            hp -= 4;
        }
    }
    cout << hp << endl;
    if(hp<=0)
    {
        Dialog * dialog = new Dialog();
        dialog->win();
        dialog->show();
        scene()->removeItem(this);
        delete this;
        return;
    }
}
